$date
	Wed Nov 12 19:57:53 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module Single_Cycle_Top_Tb $end
$var reg 1 ! clk $end
$var reg 1 " rst_n $end
$scope module sct $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var wire 1 # regw $end
$var wire 32 $ regtoalu [31:0] $end
$var wire 32 % pctoaddr [31:0] $end
$var wire 32 & pc4 [31:0] $end
$var wire 32 ' imtoreg [31:0] $end
$var wire 32 ( imexttoalu [31:0] $end
$var wire 32 ) dmtoreg [31:0] $end
$var wire 4 * cutoalu [3:0] $end
$var wire 32 + aluresult [31:0] $end
$scope module alu $end
$var wire 32 , and1 [31:0] $end
$var wire 32 - not1 [31:0] $end
$var wire 32 . or1 [31:0] $end
$var wire 32 / xor1 [31:0] $end
$var wire 1 0 zero_flag $end
$var wire 33 1 sub_ext [32:0] $end
$var wire 32 2 sub1 [31:0] $end
$var wire 32 3 srl [31:0] $end
$var wire 32 4 sra [31:0] $end
$var wire 32 5 sll [31:0] $end
$var wire 4 6 sel [3:0] $end
$var wire 1 7 overflow_flag $end
$var wire 32 8 out [31:0] $end
$var wire 1 9 negative_flag $end
$var wire 32 : i2 [31:0] $end
$var wire 32 ; i1 [31:0] $end
$var wire 1 < carry_flag $end
$var wire 33 = add_ext [32:0] $end
$var wire 32 > add1 [31:0] $end
$upscope $end
$scope module cu $end
$var wire 3 ? f3 [2:0] $end
$var wire 7 @ f7 [6:0] $end
$var wire 7 A opcode [6:0] $end
$var wire 1 B zero $end
$var wire 1 # regwrite $end
$var wire 1 C pcsrc $end
$var wire 1 D memwrite $end
$var wire 1 E memtoreg $end
$var wire 1 F memread $end
$var wire 2 G immsrc [1:0] $end
$var wire 2 H aluwire [1:0] $end
$var wire 1 I alusrc $end
$var wire 4 J alucontrol [3:0] $end
$scope module alu $end
$var wire 3 K funct3 [2:0] $end
$var wire 7 L funct7 [6:0] $end
$var wire 1 M f75 $end
$var wire 2 N aluop [1:0] $end
$var wire 4 O alucontrol [3:0] $end
$upscope $end
$scope module md $end
$var wire 7 P opcode [6:0] $end
$var wire 1 C pcsrc $end
$var wire 1 B zero $end
$var wire 1 # regwrite $end
$var wire 1 D memwrite $end
$var wire 1 E memtoreg $end
$var wire 1 F memread $end
$var wire 1 Q jump $end
$var wire 2 R immsrc [1:0] $end
$var wire 1 S branch $end
$var wire 1 I alusrc $end
$var wire 2 T aluop [1:0] $end
$upscope $end
$upscope $end
$scope module dm $end
$var wire 10 U addr [9:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var wire 32 V write [31:0] $end
$var wire 1 W write_e $end
$var wire 32 X read [31:0] $end
$upscope $end
$scope module im $end
$var wire 1 " rst_n $end
$var wire 32 Y readdata [31:0] $end
$var wire 32 Z address [31:0] $end
$upscope $end
$scope module immex $end
$var wire 32 [ inp [31:0] $end
$var wire 32 \ out [31:0] $end
$upscope $end
$scope module pa $end
$var wire 32 ] i2 [31:0] $end
$var wire 32 ^ sum [31:0] $end
$var wire 32 _ i1 [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 ! clk $end
$var wire 32 ` pcnext [31:0] $end
$var wire 1 " rst_n $end
$var reg 32 a pc [31:0] $end
$upscope $end
$scope module rg $end
$var wire 5 b addr_r1 [4:0] $end
$var wire 5 c addr_r2 [4:0] $end
$var wire 5 d addr_w1 [4:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var wire 32 e write [31:0] $end
$var wire 1 # write_enable $end
$var wire 32 f read2 [31:0] $end
$var wire 32 g read1 [31:0] $end
$var integer 32 h i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b100000 h
b0 g
b0 f
b0 e
b0 d
bz c
b0 b
b0 a
b100 `
b0 _
b100 ^
b100 ]
b0 \
b0 [
b0 Z
b0 Y
b0 X
zW
bz V
b0 U
b0 T
0S
b0 R
0Q
b0 P
b0 O
b0 N
zM
bz L
b0 K
b0 J
0I
b0 H
b0 G
0F
0E
0D
0C
zB
b0 A
bz @
b0 ?
b0 >
b0 =
0<
b0 ;
b0 :
09
b0 8
07
b0 6
b0 5
b0 4
b0 3
b0 2
b0 1
10
b0 /
b0 .
b11111111111111111111111111111111 -
b0 ,
b0 +
b0 *
b0 )
b0 (
b0 '
b100 &
b0 %
b0 $
0#
0"
0!
$end
#50
b100000 h
1!
#90
07
1I
1#
19
b1111111100 U
00
b11111111111111111111111111111100 +
b11111111111111111111111111111100 8
b11111111111111111111111111111100 /
b11111111111111111111111111111100 .
b100 2
b11111111111111111111111111111100 >
b100000000000000000000000000000100 1
b11111111111111111111111111111100 =
b11111111111111111111111111111100 (
b11111111111111111111111111111100 :
b11111111111111111111111111111100 \
1E
1F
b10 ?
b10 K
b11 A
b11 P
b110 d
b1001 b
bx )
bx X
bx e
b11111111110001001010001100000011 '
b11111111110001001010001100000011 Y
b11111111110001001010001100000011 [
bx f
1"
#100
0!
#150
x7
xI
x#
x9
bx U
x<
b0xxx *
b0xxx 6
b0xxx J
b0xxx O
bx -
x0
bx +
bx 8
bx /
bx .
bx ,
xC
bx 4
bx 3
bx 5
bx $
bx ;
bx g
bx 2
bx >
bx 1
bx =
bx (
bx :
bx \
xE
xF
xD
xS
xQ
bx H
bx N
bx T
bx G
bx R
bx ?
bx K
bx A
bx P
bx d
bx b
bx '
bx Y
bx [
b1000 &
b1000 ^
b1000 `
b100 %
b100 Z
b100 _
b100 a
1!
#200
0!
#250
b1100 &
b1100 ^
b1100 `
b1000 %
b1000 Z
b1000 _
b1000 a
1!
#300
0!
#350
b10000 &
b10000 ^
b10000 `
b1100 %
b1100 Z
b1100 _
b1100 a
1!
#390
